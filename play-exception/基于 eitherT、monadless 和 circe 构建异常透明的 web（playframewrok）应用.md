# 基于 EitherT、monadless 和 circe 构建异常透明的 web（playframewrok）应用

## 1、异常处理的那些痛

在日常的 Java 开发中，异常的处理是一个永恒不变的主题，几乎在每一处代码都能看见 try-catch-finally 语句。
有时候写了一段代码，由于不知道异常是否会在调用的方法中产生，你通常都会在外面包裹一层 try 语句。
由于方法的层层嵌套，有时候你甚至不知道一个异常被抛出后该干什么，甚至直接不管，任由系统把报错信息返回给用户。
以至于 Spring 等框架会把某些异常转化为 RuntimeException 以屏蔽内部代码复杂性。

在 Scala 中，甚至不做异常检查，异常的处理变成了可选项，可这在一定程度上降低了系统错误提示的友好性，
所以无论是在 Java 的系统或者 Scala 的系统中，你通常都会看见`系统异常，未知错误，请联系管理员`的提示字样。
有时候不过是个用户权限不足或者找不到 ID 对应的数据这些常见问题，但却因为开发的懒惰而变成了一些莫名其妙
的提示。

## 2、解决思路

在经过 @jilen 的一些启发和自己的一些摸索以后，在针对 Web 的 Playframework 的日常开发中，本人总结了一些
异常处理的看法拿出来和大家分享一下。

由于本人主要从事 Web 后端、前端开发，所以本文只针对使用 Playframework 进行开发的情况讨论。

首先要和大家明确两个问题

（1）异常处理需要做的事情。
个人的观点是，在 Web 项目中，编写逻辑代码的人员，异常处理（非逻辑性异常，逻辑相关的异常会在后面讨论）无非就是做两个事情：

a、把异常信息记录在日志上

b、向用户返回错误提示

（2）错误提示信息和错误状态码在什么时候决定。
个人的观点是，错误提示信息和错误状态码在异常发生或逻辑产生分支的那一刻就应该决定，而不是在最外层捕获异常时
才去想到底应该返回什么信息给用户。

如根据用户 ID 返回用户信息这一条逻辑，在 UserTable.filter(...).headOption 为 None 的那一刻就应该决定错误提示
信息为`找不到 ID 为 2333 的用户`和错误代码是 404，而不是专门构造一个 UserNotFoundException 然后在最外层捕获，
更不应该直接提示一个系统错误或者返回 500 页面。

分析一下上面两个条件，简而言之，就是需要在异常发生的时候记录日志，编写异常信息，并且一直保留到最后直到输出给用户，
这个抽象可以用 Either 来表示，而 Scala 需要使用 Future 来表示异步，于是可以用`Futre[Either[ErrorResult, T]]`或者
更准确的`EitherT[Future, ErrorResult, T]`来代表主体数据类型为 T 的数据所被包装的数据类型。而在一般 Web 应用中，
还需要携带一些错误提示信息和返回的状态码，于是作为相应的结果，这个`EitherT[Future, ErrorResult, T]`通常会变为
`EitherT[Future, ErrorResult, TableData[T]]`，但，这，还没是完全版。

单单把`EitherT[Future, ErrorResult, T]`作为一个包装类型在各个方法间传递的话，难免会因为不断的回调和不断的装箱
操作而令得你的代码可读性变得一团糟，给人一种想回到捕捉异常的方式的冲动。在这个时候，本来平时处于辅助状态的一个可以令异步
代码同步化的框架`monadless`（也可以用`each`）在这里就起到了不可替代、不可缺少的作用了。

## 3、前期代码准备

为了使这个复杂的类型`EitherT[Future, ErrorResult, T]`使用起来和普通的`Future[T]`的区别降到最小，在这里需要做一些
准备工作。